
postgres
h2
sql server

webflux, 到了数据库都是一个同步的操作，spring团队在积极的解决这个问题

数据访问进阶相关

aop
摘要
sql日志

函数式编程

云原生：

云原生技术有利于各个组织在公有云、私有云和混合云等新型动态环境中，
构建和运行弹性扩展的应用。提高效率降低成本。

微服务: 一些 协同工作 小 自治（单一职责） 服务

异构性
弹性
易于部署
与组织结构对齐，交给不同的团队来处理，各自对系统做负责
可组合性（）

没有银弹：
分布式系统的复杂性
开发测试诸多研发过程的复杂性
部署、监控等诸多运维复杂性

最佳实践

单体
soa
cloud

微服务实战

cloud-native

devops：开发与运维一同致力于交付高品质软件服务于客户（研发就要考虑运维的点：部署，监控，成本，运维成本等，如何恢复处理，恢复补偿）
continuous delivery: 十倍程序员工作法（下一轮学习的内容）
  软件的构建、测试和发布，要更快，更频繁、更稳定
微服务：以一组小型服务的形式来部署应用
容器：提供比传统虚拟机更高的效率：生产环境中更是如此，一般都有提供k8s的支持

cncf：公有云基金会，认识和理解cloud native
k8s 普罗米修斯 envoy：华人主导的项目：etcd， 蜻蜓镜像分发。项目列表，镜像管理的设施。

有效的最佳时间，给saas应用提供行之有效的方法论。
适合用于任意语言和后端服务的开发的应用程序。

12条：

codebase: 一份基准代码，多份部署（只要一个模块）
依赖：显示声明依赖关系
配置：在环境中存储配置（代码和配置分离、外置配置文件、配置中心）
后端服务：将后端服务当做附加资源
构建，发布，运行：build,release,run：严格分离构建和运行
进程：一个或多个无状态进程运行应用
通过端口绑定提供服务
并发:进程的模型进行扩展，用线程模型。多机房
已处理：快速启动和有呀终止可最大化健壮性。
开发环境与线上环境等价：尽可能的保持开发，预发布，线上环境相同
日志：日志当做事件流，elk，filebeat收集，结构化的收集起来
管理进程：后台管理任务当做一次性进程运行。

maven: 有一些包会发生一些变化，不同的版本同时被引用进来，建议使用扫描工具做处理。
定期的扫描，看下有么有变化。

build push（也可以每个一个）、release（发布版本唯一id）、run、用完整的包做处理
发布平台，发布包的推送，多的话可以考虑使用p2p的方式发送过去。


无状态的进程：可以是适当的在进程中加入状态。jvm内部做缓存，在特定的进程里面。
前端的请求和策略使用一致性hash来落到特定的机器上面。一定程度上面提升性能。所有的进程都是一样的。
需要持久化的数据，都存在后端资源中。

快速启动和优雅下线：
进程应当最求最小启动时间
进程一旦接受终止信号就会优雅终止
进程应当在面对突然死亡的时候保持健壮。
在当前在跑的全部停止掉，在连接全部降到0了之后就优雅下线
先从负载均衡扯下来，确定没有请求了，在进行处理

在突然死亡保持健壮。磁盘、网络、io除了问题不可怕，没法恢复才可怕。

保证开发，预发布，线上，类似。只有相识的时候，才可能在线下发现问题。环境的差异照成各种各样的问题

相对的编程模型：
服务发现和注册：更多的精力放到业务逻辑的实现上面了。
api网关：
配置
监控
微服务
注册中心
消息中间件
数据库


监控，消息关联起来，通过springcloud机制。
公有云平台的支持。


spring cloud 规则：
release train，伦敦地铁站的字幕排序，最新的版本是greenwich，Serivce Release

线上使用eureka的集群来处理
